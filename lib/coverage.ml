let is_docdriven_generated path =
  try
    let ic = open_in path in
    let rec check_lines count =
      if count > 5 then false  (* Only check first 5 lines *)
      else
        try
          let line = input_line ic in
          let lower = String.lowercase_ascii line in
          if Str.string_match (Str.regexp ".*generated by docdriven.*") lower 0 then
            true
          else
            check_lines (count + 1)
        with End_of_file -> false
    in
    let result = check_lines 0 in
    close_in ic;
    result
  with
  | Sys_error _ -> false

let scan_directory base_dir exclude_patterns =
  let rec collect_files dir =
    if Sys.file_exists dir && Sys.is_directory dir then
      let entries = Sys.readdir dir in
      Array.fold_left (fun acc entry ->
        let full_path = Filename.concat dir entry in
        let rel_path = if String.length base_dir > 0 && String.starts_with ~prefix:base_dir full_path then
          let base_len = String.length base_dir in
          let path_after = String.sub full_path (base_len + 1) (String.length full_path - base_len - 1) in
          path_after
        else
          full_path
        in
        
        (* Check if path matches any exclude pattern *)
        let excluded = List.exists (fun pattern ->
          Selector.matches_pattern pattern rel_path
        ) exclude_patterns in
        
        if excluded then acc
        else if Sys.is_directory full_path then
          (* Skip hidden and common build directories *)
          if String.starts_with ~prefix:"." entry || 
             entry = "node_modules" || entry = "_build" || entry = "build" ||
             entry = "dist" || entry = "target" || entry = "__pycache__" then
            acc
          else
            collect_files full_path @ acc
        else
          (* Only count actual code files, skip common non-code files *)
          if entry = ".gitignore" || entry = ".gitattributes" || 
             entry = ".DS_Store" || String.ends_with ~suffix:".lock" entry ||
             String.ends_with ~suffix:".log" entry then
            acc
          else
            full_path :: acc
      ) [] entries
    else
      []
  in
  collect_files base_dir

let calculate_coverage repo_dir _config_files exclude_patterns =
  let all_files = scan_directory repo_dir exclude_patterns in
  let total = List.length all_files in
  
  let generated_files = List.filter is_docdriven_generated all_files in
  let generated_count = List.length generated_files in
  
  let coverage_pct = if total = 0 then 0.0 else
    (float_of_int generated_count /. float_of_int total) *. 100.0
  in
  
  let manual_count = total - generated_count in
  let manual_pct = 100.0 -. coverage_pct in
  
  (total, generated_count, coverage_pct, manual_count, manual_pct, all_files, generated_files)

let print_coverage_report repo_name stats verbose =
  let (total, generated_count, coverage_pct, manual_count, manual_pct, all_files, generated_files) = stats in
  
  Printf.printf "[%s] Documentation Coverage:\n" repo_name;
  Printf.printf "─────────────────────────────────────────────────\n";
  Printf.printf "Total files:           %d\n" total;
  Printf.printf "Docdriven-managed:     %d (%.1f%%)\n" generated_count coverage_pct;
  Printf.printf "Manually written:      %d (%.1f%%)\n\n" manual_count manual_pct;
  
  if verbose && total > 0 then begin
    if generated_count > 0 then begin
      Printf.printf "Docdriven-managed files:\n";
      List.iter (fun path ->
        Printf.printf "  ✓ %s\n" path
      ) generated_files;
      Printf.printf "\n"
    end;
    
    let manual_files = List.filter (fun f -> not (List.mem f generated_files)) all_files in
    if manual_count > 0 then begin
      Printf.printf "Manually written files:\n";
      List.iter (fun path ->
        Printf.printf "  • %s\n" path
      ) manual_files;
      Printf.printf "\n"
    end
  end

let analyze_coverage config repo_names output_dirs exclude_patterns verbose =
  let target_repos = if repo_names = [] then
    List.map (fun r -> r.Config.name) config.Config.repos
  else
    repo_names
  in
  
  List.iter (fun repo_name ->
    let repo = try
      List.find (fun r -> r.Config.name = repo_name) config.Config.repos
    with Not_found ->
      failwith (Printf.sprintf "Repo '%s' not found in config" repo_name)
    in
    
    let repo_dir = try
      List.assoc repo_name output_dirs
    with Not_found ->
      failwith (Printf.sprintf "Directory not specified for repo '%s'. Use -o DIR or set DOCDRIVEN_%s_LOCAL in .env" repo_name repo_name)
    in
    
    if not (Sys.file_exists repo_dir) then
      Printf.printf "[%s] Warning: Directory does not exist: %s\n\n" repo_name repo_dir
    else begin
      let config_files = Selector.collect_repo_files repo in
      let stats = calculate_coverage repo_dir config_files exclude_patterns in
      print_coverage_report repo_name stats verbose
    end
  ) target_repos
